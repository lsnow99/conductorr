package mycsl

import (
	"fmt"
	"regexp"
	"strconv"
)

const (
	numericVal = iota
	stringVal
	varVal
	addVal
	subVal
	multVal
	divVal
)

type valType uint8

type Value struct {
	Type valType
	Val  interface{}
}

type Expr struct {
	Val      *Value
	LeftVal  *Expr
	RightVal *Expr
}

type Tokens []*Token

type tokenType uint8

type Token struct {
	typ tokenType
	val string
}

type Pattern struct {
	typ    tokenType
	regexp *regexp.Regexp
}

func (t Token) String() string {
	return fmt.Sprintf("%v", t.val)
}

func (e *Expr) String() string {
	level := 0
	exprs := e.getExprAtLevel(level)
	str := ""
	for exprs != nil && len(exprs) > 0 {
		str += fmt.Sprintf("\nLevel %d: ", level)
		for _, e := range exprs {
			leftStr, rightStr := "NIL", "NIL"
			if e.LeftVal != nil {
				leftStr = e.LeftVal.Val.String()
			}
			if e.RightVal != nil {
				rightStr = e.RightVal.Val.String()
			}
			str += fmt.Sprintf("(%v left:%v right:%v)", e.Val, leftStr, rightStr)
		}
		level++
		exprs = e.getExprAtLevel(level)
	}
	return str
}

func (v *Value) String() string {
	if v == nil {
		return "nil"
	}
	switch v.Type {
	case numericVal:
		return fmt.Sprintf("%d", v.Val)
	case stringVal:
		return v.Val.(string)
	case varVal:
		return v.Val.(string)
	case addVal:
		return "+"
	case subVal:
		return "-"
	case multVal:
		return "*"
	case divVal:
		return "/"
	default:
		return fmt.Sprintf("type%d", v.Type)
	}
}

func (e *Expr) getExprAtLevel(level int) []*Expr {
	if e == nil {
		return nil
	}

	if level < 0 {
		return nil
	} else if level == 0 {
		return []*Expr{e}
	} else if level > 0 {
		leftExprs := e.LeftVal.getExprAtLevel(level - 1)
		rightExprs := e.RightVal.getExprAtLevel(level - 1)
		return append(leftExprs, rightExprs...)
	}

	return nil
}

func (toks Tokens) findClose() int {
	opens := -1
	for index, tok := range toks {
		if tok.typ == openToken {
			opens++
		} else if tok.typ == closeToken {
			if opens == 0 {
				return index
			} else {
				opens--
			}
		}
	}
	return -1
}

const (
	whitespaceToken tokenType = iota
	commentToken
	stringToken
	numberToken
	openToken
	closeToken
	symbolToken
	nilToken
)

func Parse(script string) *Expr {
	toks := NewTokens(script)
	return ParseTokens(toks)
}

func ParseTokens(toks Tokens) *Expr {
	root := &Expr{}
	if len(toks) < 1 {
		return nil
	}
	tok := toks[0]
	if tok.typ == openToken {
		newRoot := &Expr{}
		newRoot.LeftVal = ParseTokens(toks[1:2])
		newRoot.RightVal = ParseTokens(toks[2:toks.findClose()])
		root.LeftVal = newRoot
		if toks.findClose() < len(toks) {
			root.RightVal = ParseTokens(toks[toks.findClose():])
		}
	} else if tok.typ == closeToken {
		root.RightVal = nil
		root.LeftVal = nil
	} else if tok.typ == symbolToken {
		switch tok.val {
		case "+":
			root.Val = &Value{
				Type: addVal,
			}
			break
		case "-":
			root.Val = &Value{
				Type: subVal,
			}
			break
		case "*":
			root.Val = &Value{
				Type: multVal,
			}
			break
		case "/":
			root.Val = &Value{
				Type: divVal,
			}
			break
		default:
			root.Val = &Value{
				Type: varVal,
				Val:  tok.val,
			}
		}
	} else if tok.typ == stringToken {
		root.LeftVal = &Expr{
			Val: &Value{
				Val:  tok.val,
				Type: stringVal,
			},
		}
		root.RightVal = ParseTokens(toks[1:])
	} else if tok.typ == numberToken {
		num, _ := strconv.ParseInt(tok.val, 10, 64)
		root.LeftVal = &Expr{
			Val: &Value{
				Val:  num,
				Type: numericVal,
			},
		}
		root.RightVal = ParseTokens(toks[1:])
	}
	if root.Val == nil && root.LeftVal == nil && root.RightVal == nil {
		return nil
	}
	return root
}

func patterns() []Pattern {
	return []Pattern{
		{whitespaceToken, regexp.MustCompile(`^\s+`)},
		{commentToken, regexp.MustCompile(`^;.*`)},
		{stringToken, regexp.MustCompile(`^("(\\.|[^"])*")`)},
		{numberToken, regexp.MustCompile(`^((([0-9]+)?\.)?[0-9]+)`)},
		{openToken, regexp.MustCompile(`^(\()`)},
		{closeToken, regexp.MustCompile(`^(\))`)},
		{symbolToken, regexp.MustCompile(`^('|[^\s();]+)`)},
	}
}

func NewTokens(program string) (tokens Tokens) {
	for pos := 0; pos < len(program); {
		for _, pattern := range patterns() {
			if matches := pattern.regexp.FindStringSubmatch(program[pos:]); matches != nil {
				if len(matches) > 1 {
					tokens = append(tokens, &Token{pattern.typ, matches[1]})
				}
				pos = pos + len(matches[0])
				break
			}
		}
	}
	return
}
